### 虚拟内存

虚拟内存就是在你电脑的物理内存不够用时把一部分硬盘空间作为内存来使用，这部分硬盘空间就叫作虚拟内存。

硬盘传输的速度要比内存传输速度慢的多，所以虚拟内存比物理内存的效率要慢得多。

断电后数据丢失。

### 虚拟地址空间

虚拟地址空间是一个非常抽象的概念，先根据字面意思进行解释：

- 它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）
- 它对应着一段连续的内存地址，起始位置为 0。

- 之所以说虚拟是因为这个起始的 0 地址是被虚拟出来的， 不是物理内存的 0 地址。

虚拟地址空间的大小也由操作系统决定，32位的操作系统虚拟地址空间的大小为 2^32 字节，也就是 4G，64 位的操作系统虚拟地址空间大小为 2^64 字节，这是一个非常大的数，感兴趣可以自己计算一下。

关于虚拟4G内存的描述和解析：

一个进程用到的虚拟地址是由内存区域表来管理的，实际用不了4G。而用到的内存区域，会通过页表映射到物理内存。

所以每个进程都可以使用同样的虚拟内存地址而不冲突，因为它们的物理地址实际上是不同的。内核用的是3G以上的1G虚拟内存地址，其中896M是直接映射到物理地址的，128M按需映射896M以上的所谓高位内存。各进程使用的是同一个内核。

首先要分清“可以寻址”和“实际使用”的区别。

其实我们讲的每个进程都有4G虚拟地址空间，讲的都是“可以寻址”4G，意思是虚拟地址的0-3G对于一个进程的用户态和内核态来说是可以访问的，而3-4G是只有进程的内核态可以访问的。并不是说这个进程会用满这些空间。

其次，所谓“独立拥有的虚拟地址”是指对于每一个进程，都可以访问自己的0-4G的虚拟地址。虚拟地址是“虚拟”的，需要转化为“真实”的物理地址。

好比你有你的地址簿，我有我的地址簿。你和我的地址簿都有1、2、3、4页，但是每页里面的实际内容是不一样的，我的地址簿第1页写着3你的地址簿第1页写着4，对于你、我自己来说都是用第1页（虚拟），实际上用的分别是第3、4页（物理），不冲突。

内核用的896M虚拟地址是直接映射的，意思是只要把虚拟地址减去一个偏移量（3G）就等于物理地址。同样，这里指的还是寻址，实际使用前还是要分配内存。而且896M只是个最大值。如果物理内存小，内核能使用（分配）的可用内存也小。



进程的虚拟地址空间分为用户区(0~3G)和内核区(3~4G), 其中内核区是受保护的, 用户是不能够对其进行读写操作的；

**内核区对于所有进程是共享的；系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。**

![img](https://cdn.nlark.com/yuque/0/2021/png/1546890/1633790560082-defa12a7-33aa-41d3-afd1-19f16eb89021.png)

虚拟地址空间中用户区地址范围是 0~3G，里边分为多个区块：

- **保留区**: 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。
- **.text段**: 代码段也称正文段或文本段，通常用于存放程序的执行代码 (即 CPU 执行的机器指令)，代码段一般情况下是只读的，这是对执行代码的一种保护机制。

- **.data段**: 数据段通常用于存放程序中已初始化且初值不为 0 的全局变量和静态变量。数据段属于静态内存分配 (静态存储区)，可读可写。
- .**bss段**: 未初始化以及初始为 0 的全局变量和静态变量，操作系统会将这些未初始化变量初始化为 0

- **堆(heap)**：用于存放进程运行时动态分配的内存。

- - 堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。
  - 堆向高地址扩展 (即 “向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。

- **内存映射区(mmap)**：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。
- **栈(stack)**: 存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反地址 “向下生长”，分配的内存是连续的。

- **命令行参数**：存储进程执行的时候传递给 main() 函数的参数，argc，argv []，env[]
- **环境变量**: 存储和进行相关的环境变量，比如：工作路径，进程所有者等信息

### 内存管理单元MMU

MMU位于CPU内，作用：

- 程序中使用的地址均是虚拟内存地址，进程中的数据是如何进出入到物理内存中的呢？
- **MMU完成虚拟内存到物理内存的映射，即虚拟地址映射为物理地址；**

- **流水线中预取指令取到的地址是虚拟地址，需要MMU转换以及设置访问权限**

**MMU采用分页机制(即按页来划分物理内存)** 

**用MMU的是**：Windows、MacOS、Linux、Android；

**不用MMU的是**：FreeRTOS、VxWorks、UCOS……

与此相对应的：CPU也可以分成两类，带MMU的、不带MMU的。

**带MMU的是**：Cortex-A系列、ARM9、ARM11系列；

**不带MMU的是**：Cortex-M系列……（STM32是M系列，没有MMU，不能运行Linux，只能运行一些UCOS、FreeRTOS等等）。

虚拟地址和物理地址的映射关系存储在页表中，而现在页表又是分级的

**页表**：

实现从页号到物理块号的地址映射。

逻辑地址转换成物理地址的过程是：用页号p去检索页表，从页表中得到该页的物理块号，把它装入物理[地址寄存器](https://baike.baidu.com/item/地址寄存器)中。同时，将页内地址d直接送入物理[地址寄存器](https://baike.baidu.com/item/地址寄存器)的块内地址字段中。这样，物理[地址寄存器](https://baike.baidu.com/item/地址寄存器)中的内容就是由二者拼接成的实际访问内存的地址，从而完成了从[逻辑地址](https://baike.baidu.com/item/逻辑地址)到物理地址的转换。

**TLB快表**：

TLB是MMU中的一块高速缓存,也是一种Cache.

TLB就是页表的Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。只有在TLB无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。

**如果没有TLB，则每次取数据都需要两次访问内存,即查页表获得物理地址和取数据.**



虚拟地址空间以**页**为单位进行划分，而相应的物理地址空间也被划分，其使用的单位称为**页帧**，页帧和页必须保持相同，因为**内存与外部存储器之间的传输是以页为单位进行传输的**。例如，MMU可以通过一个映射项将VA的一页0xb70010000xb7001fff映射到PA的一页0x20000x2fff，如果CPU执行单元要访问虚拟地址0xb7001008，则实际访问到的物理地址是0x2008。

虚拟内存的哪个页面映射到物理内存的哪个页帧是通过**页表（Page Table）**来描述的，页表保存在**物理内存中**，**MMU会查找页表来确定一个VA应该映射到什么PA。**

- **内存访问级别的设置和修改(内存保护)**，在完成映射的同时，会设置CPU访问该段内存的访问级别(3,2,1,0  Linux只有用户空间3，内核空间0)，

如图：

ro表示read only

0和3表示访问级别

程序运行了两次，产生两个独立的进程，因此虚拟地址空间不一样

两个进程共用一个内核区，映射一份(图中也要通过MMU映射，懒得话而已)即可，其中**两个进程的PCB不一样**

用户区需要单独映射

![img](https://cdn.nlark.com/yuque/0/2021/png/1546890/1626187559093-a6fd456a-69f4-4cbc-988c-7f76dbc1f2f5.png)

#### MMU执行过程

OS和MMU是这样配合的：

1. 操作系统在初始化或分配、释放内存时会执行一些指令在物理内存中填写页表，然后用指令设置MMU，告诉MMU页表在物理内存中的什么位置。
2. 设置好之后，CPU每次执行访问内存的指令都会自动引发MMU做查表和地址转换操作，地址转换操作由硬件自动完成，不需要用指令控制MMU去做。

我们在程序中使用的变量和函数都有各自的地址，在程序被编译后，这些地址就成了指令中的地址，指令中的地址就成了CPU执行单元发出的内存地址，所以在启用MMU的情况下， 程序中使用的地址均是**虚拟内存地址**，都会引发MMU进行查表和地址转换操作。（注意理解这句话）

### 内存保护机制

#### 中断和异常

- 中断由外部设备产生，而 异常由CPU内部产生的
- 中断产生与CPU当前执行的指令无关，而异常是由于当前执行的指令出现问题导致的g

处理器一般有**用户模式（User Mode）**和**特权模式（privileged Mode）**之分。操作系统可以在页表中设置每个页表访问权限，有些页表不可以访问，有些页表只能在特权模式下访问，有些页表在用户模式和特权模式下都可以访问，同时，访问权限又分为**可读**、**可写**和**可执行**三种。这样设定之后，当CPU要访问一个VA（Virtual Address）时，**MMU**会检查CPU当前处于用户模式还是特权模式，访问内存的目的是读数据、写数据还是取指令执行，**如果与操作系统设定的权限相符，则允许访问，把VA转换成PA，否则不允许执行，产生异常（Exception）**。



**在正常情况下处理器在用户模式执行用户程序，在中断或异常情况下处理器切换到特权模式执行内核程序，处理完中断或异常之后再返回用户模式继续执行用户程序。**

**段错误**我们已经遇到过很多次了，它是这样产生的：

1. 用户程序要访问的一个虚拟机地址，经MMU检查无权访问。
2. MMU产生一个异常，CPU从用户模式切换到特权模式，跳转到内核代码中执行异常服务程序。

1. 内核把这个异常解释为段错误，把引发异常的进程终止掉。

### 用户空间与内核通信方式有哪些？

1)系统调用。用户空间进程通过系统调用进入内核空间，访问指定的内核空间数据；

2)共享映射区mmap。在代码中调用接口，实现内核空间与用户空间的地址映射，在实时性要求很高的项目中为首选，省去拷贝数据的时间等资源，但缺点是不好控制；

3)驱动程序。用户空间进程可以使用封装后的系统调用接口访问驱动设备节点，以和运行在内核空间的驱动程序通信；

4)copy_to_user()、copy_from_user()，是在驱动程序中调用接口，实现用户空间与内核空间的数据拷贝操作，应用于实时性要求不高的项目中。
