操作系统中的CPU和主存都是稀缺资源，所有运行在当前操作系统的进程会共享系统中的CPU和内存资源，操作系统会使用CPU调度器分配CPU事件并引入虚拟内存管理物理内存。

虚拟内存是操作系统物理内存和进程之间的中间层，它为进程隐藏了物理内存这一概念，为进程提供了更加简洁和易用的接口以及更加复杂的功能。



![img](https://cdn.nlark.com/yuque/0/2020/png/439735/1586677688877-c22bfb39-5e9b-49ef-bdbb-93de8cad5720.png)

早期的操作系统中，进程会直接使用目标内存的物理地址直接访问主存中的内容，然而现代的操作系统都引入了虚拟内存，进程持有的虚拟地址会经过内存管理单元（MMU）的转换为物理地址，然后通过物理地址访问内存

![img](https://cdn.nlark.com/yuque/0/2020/png/439735/1586688421165-0ccef3f0-5384-4327-a22b-3f85b07564cf.png)

主存是相对比较稀缺的资源，虽然顺序读取只比磁盘快1各数量级，但是它能提供极快的随机访问速度，从内存上随机读取数据的速度是磁盘的100000倍。

操作系统以页作为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统会以页的方式加载到内存中，这个过程是MMU完成的。

虚拟内存起到了以下三个非常关键的作用：

- 虚拟内存可以利用磁盘起到缓存的作用，提高进程访问指定内存的速度。
- 虚拟内存可以为进程提供独立的内存空间，简化程序的链接、加载过程并通过动态库共享内存。

- 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。



## 缓存

我们可以把虚拟内存看作是磁盘上的一片空间，当这片空间的一部分访问比较频繁时，这部分数据会以页为单位缓存到主存中以加速CPU访问数据的性能，虚拟内存利用空间较大的磁盘存储作为内存并是使用主存缓存进行加速，**让上层认为操作系统的内存很大而且很快，然而区域很大的磁盘并不快，而很快的内存也并不大。**

![img](https://cdn.nlark.com/yuque/0/2020/png/439735/1586689372372-f5021c63-4560-4185-a39b-50a6765b2f19.png)

虚拟内存中的虚拟页可能处于以下三中状况——未分配、未缓存和已缓存，其中未分配的内存页事没有被进程申请使用的，也就是空闲的虚拟内存，不占用虚拟内存磁盘的任何空间，未缓存和已缓存的内存页分别表示已经加载到主存中的内存页和仅加载到磁盘中的内存页。

当用户程序访问未被缓存的虚拟页时候=，硬件就会触发缺页中断，在部分情况下，被访问的页面已经加载到物理内存中，但是用户程序的页表并不存在该对应关系，这时候我们只需要在页表中建立虚拟内存到物理内存的关系；在其他情况下，操作系统需要把磁盘上未被缓存的虚拟页加载到物理内存中。

![img](https://cdn.nlark.com/yuque/0/2020/png/439735/1586691195142-945d4264-a6df-4155-950d-54333f4d82ac.png)

因为主内存的空间是有限的，当主内存中不包含可以使用的空间时，操作系统会选择合适的物理内存驱除回磁盘，为新的内存让出位置，选择待驱除的页的过程在操作系统中叫做页面替换。缺页中断和页面替换都是操作系统调页算法的一部分。

## 内存管理

虚拟内存可以为正在运行的进程提供独立的内存空间，制造一种每个进程的内存都是独立的假象。在64位的操作系统上，每个进程都由256TiB的内存空间，内核和用户空间分别占128TiB。因为每个进程的虚拟内存空间是完全独立的。![img](https://cdn.nlark.com/yuque/0/2020/png/439735/1586691827556-8a5ae9fb-3adc-44fd-8afd-868b62bd0892.png)

虚拟内存只是操作系统中的逻辑结构，应用程序最终还是需要访问物理内存或磁盘上的内容，因为操作系统加了一个虚拟内存的中间层，所以我们也需要为进程实现地址翻译器，实现从虚拟地址到物理地址的转换，页表是虚拟内存系统中重要的数据结构，每一个进程的页表中都存储了从虚拟内存到物理内存的映射关系，为了存储64位系统中128TiB虚拟内存的映射数据，Linux在2.6.10中引入了四层的页表来辅助虚拟地址的转换，在4.11中引入了五层的页表结构。

![img](https://cdn.nlark.com/yuque/0/2020/png/439735/1586743580200-de9c30f0-c48c-43e5-a831-2a27cbbfe697.png)

在上图所示的四层页表结构中，操作系统会使用最低的12位作为页面的偏移量，剩下的32位会分四组分别表示当前层级在上一层的索引，所有的虚拟地址都可以用上述的多层页表查找到对应的物理地址。

所以多个进程可以通过虚拟内存共享物理内存。在Linux中调用fork的时候，实际上只复制了父进程的页表。父子进程会通过不同的页表指向相同的物理内存。

![img](https://cdn.nlark.com/yuque/0/2020/png/439735/1586744970095-66ad2d65-a110-4d3b-adb0-79df34e163cb.png)

虚拟内存不仅可以在fork时用于共享进程的物理内存，提供写时复制的机制。还能共享一些常见的动态库减少物理内存的占用、所有的进程都可能调用相同的操作系统内核代码，而C语言也会调用相同的标准库。

除了能够共享内存之外，独立的虚拟内存空间也会简化内存的分配过程，当用户程序向操作系统申请堆内存时，操作系统可以分配几个连续的虚拟页，但是这些虚拟页对应到物理内存中不连续的页。

## 内存保护

操作系统中的用户程序不应该修改只读的代码段，也不应该读取或修改内核中的代码和数据结构或者访问私有的的以及其他的进程的内存，如果无法对用户程序的内存访问进行限制，攻击者就可以访问和修改其他进程的内存影响系统的安全。

如果每一个进程都持有独立的虚拟空间，那么虚拟内存中页表可以理解为进程和物理页的连接表，其中可以存储进程和物理页之间的访问关系，包括读权限、写权限和执行权限：

![img](https://cdn.nlark.com/yuque/0/2020/png/439735/1586746676182-d6998fc2-b595-4aec-a190-72f15048433d.png)

MMU可以决定当前进程是否是否有权限访问目标的物理内存，这样我们就最终将权限管理的功能全部收敛到虚拟内存系统中。

# 总结

Linux中为什么需要虚拟内存：

- 虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够块并且容量足够大的存储
- 虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译为物理内存，进程之间可以互相共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程

- 虚拟内存可以控制进程对物理内存的访问、隔离不同进程的访问权限，提高系统的安全性

